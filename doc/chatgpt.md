了解しました。天鳳ルールを基に、立直麻雀のロジックに特化したC#ライブラリの設計を行い、APIやユースケースの構造、開発のマイルストーン、参考資料を含めた詳細な計画を作成します。

設計では、プレイヤー、牌山、河、手牌、点数などを適切にモジュール化し、柔軟に拡張できるように考慮します。完了次第ご連絡いたします。


# 機能・要件

* **共通要素**: プレイヤー、局管理（GameManager）、牌山、河（捨て牌集合）、手牌、鳴き（ポン・チー・カン）、リーチ、局ごとの持ち点・供託・本場などをモデル化します。点数計算モジュールは外部化されている前提なので、ライブラリ内では和了判断や翻符計算のトリガーまでを担当し、実際の点数処理は専用モジュールに委譲します。
* **プレイヤー**: `Player` クラスは手牌（`Hand`）・鳴き済み副露（Melds）・捨て牌リスト・現在の持ち点・リーチ状態などを保持。ツモ・打牌・リーチ宣言・鳴き要求・和了選択といった操作を提供します。
* **牌山（山）**: `Wall` クラスで136枚（赤ドラ含む）の牌を初期化・シャッフルし、ドラ表示牌や裏ドラも管理します。牌山からのツモや、カン発生時の杠裏ドラ表示を制御します。
* **河（捨て牌）**: 各プレイヤーの捨て牌を保持する `River`（または `Board`）クラスを用意し、誰がどの牌を捨てたか管理します。ダブルロン時の処理やフリテン判定に利用します。
* **局管理**: `GameManager` または `RoundManager` クラスで東南戦や連荘処理を制御します。ノーテン親流れ、聴牌連荘、サドンデス終了、飛び終了など天鳳ルール固有の進行ルールを実装します。開始持ち点25000・返し30000点、ウマ10-20、供託棒1000点、赤ドラ各1枚など天鳳規定も反映します。
* **拡張性**: 設定可能なルールオプション（食い断あり/なし、赤ドラ枚数、両面リーチの扱いなど）を持つ `Ruleset` クラスを導入し、ゲーム進行時に参照します。新しいルール追加が容易なように戦略パターンや依存性注入（DI）を活用し、たとえば鳴き判定や連荘判定のロジックを切り替え可能にします。

にあるような麻雀ライブラリ（kobalab/majiang-core）は、`Shoupai`（手牌）、`Shan`（牌山）、`He`（河）など基本クラスを提供し、ルール進行（`Game`）や卓情報（`Board`）、プレイヤー基底（`Player`）を備えています。これを参考に、C#版でも同様の役割分担を設計します。

## 設計方針

* **ロジック専念**: UIや入出力を持たず、純粋にゲーム進行ロジックと状態管理に特化します。外部からはイベントやコールバック（デリゲート）で動作を通知し、外部コード（UI/AI）が応答できるようにします。たとえば牌がツモられた際に `OnDraw`、牌を捨てた際に `OnDiscard`、和了時に `OnWin` のようなイベントを発行します。
* **状態管理**: 全ゲームを通して不変・変更される状態（局風、局数、本場数、供託、リーチ棒、プレイヤーごとの点数）を `GameState` または `RoundState` オブジェクトで一元管理します。状態遷移は明確なメソッド（`StartRound()`, `EndRound()`, `AdvanceEastWest()` など）で扱い、誤った状態遷移を防ぎます。
* **プレイヤー順序**: 4人打ちで固定。最初は東1局からスタートし、各自順番にツモ・打牌させます。リーチ宣言や鳴きなどを経て局終了後に次局（連荘または流局）に移行します。**ノーテン親流れ**は実装し、**聴牌親連荘**もオプションで実装します。
* **拡張と再利用**: `IPlayer` インターフェースや抽象クラスを作り、AIやUI連携用の独自実装を可能にします。点数計算は外部モジュールに任せるため、`IScoreCalculator` としてインターフェース定義し、別途実装（既存モジュール）を差し替えて使えるようにします。こうして基本エンジンは他の用途（AIシミュレーション、牌譜解析、マルチプレイヤーサーバーなど）でも流用可能とします。

## クラス構成（依存関係）

* **`GameManager`**: ゲーム全体の進行を管理。内部に `Wall`、`List<Player>`、`River`（捨て牌テーブル）、`Ruleset`、スコア管理情報（本場・供託など）を持つ。メソッド例：`StartGame()`, `DrawTile(Player)`, `DiscardTile(Player, Tile)`, `ClaimMeld(Player, MeldType)`, `DeclareRiichi(Player)`, `DeclareWin(Player, WinType)`, `EndRound()`, `CheckGameEnd()` 等。
* **`Player`**: プレイヤー1人分を表現。`Hand`（手牌オブジェクト）、`int Score`（持ち点）、`bool InRiichi`（リーチ中フラグ）、`List<Meld>`（鳴き副露一覧）、`List<Tile> Discarded`（捨て牌）。メソッド例：`Draw()`, `Discard(Tile)`, `CanRiichi()`, `DeclareRiichi()`, `CanChi(Tile)`, `CanPon(Tile)`, `CanKan(Tile)` など。上位層からの入力（AI/人間）を受けるインターフェースとして設計。
* **`Hand`**: 手牌の牌集合を管理。ツモ牌や鳴き牌が加わるたびに和了可能性（リーチ・ツモ成立）を判定できるように保持。`AddTile(Tile)`, `RemoveTile(Tile)`, `IsWinningHand()` などを提供します（点数計算は外部担当）。
* **`Wall`**: 牌山を表現。初期化時に136枚（3つの赤ドラを含む）をシャッフルし、山札と嶺上（裏ドラゾーン）を用意。`Draw()`, `KanDraw()`, `RevealDora()` メソッドで牌を出します。嶺上牌やドラ表示の処理はここで行います。
* **`River`**: 各プレイヤーの捨て牌を記録。多人数によるダブルロン判定やフリテン判定（捨て牌から危険牌チェック）に利用。必要に応じて列形式で表示できるよう、プレイヤーごとの捨て牌リストを保持します。
* **`Meld`**: ポン・チー・カンを表す構造。どの牌を使ったか（例：Ponなら同一牌3枚）、誰から鳴いたか、暗槓／加槓も含める。`MeldType` 列挙（Pon/Chi/Kan/AnKan/KanKan）と関連データを持ちます。
* **`Tile`**: 麻雀牌を表現。数牌や字牌、赤ドラなどを表す列挙型またはクラス。イミュータブルで、柄と種類を持ちます。
* **`Ruleset`**: ゲームルール設定をまとめたクラス。`AllowRedFives`（赤ドラ有無）、`AllowKuitan`、`DoubleRonAllowed`、`Uma`（ウマ）、`StartingScore` などのプロパティを持ちます。`GameManager`はこの情報を基に進行を制御します。
* **依存関係図（概念）**: `GameManager`→`Wall`、`List<Player>`、`River`、`Ruleset`、`IScoreCalculator`。`Player`→`Hand`、`List<Meld>`、`Score`。`Hand`→`Tile`。`Wall`→`Tile`。これらのクラスは互いに結合度を低くし、責務を分離することで柔軟性を確保します。

このように、kobalab/majiang-core のような構成を参考に、**ゲーム進行管理層**（Game/GameManager）、**プレイヤー層**（Player/Hand）、**状態層**（Wall/River/Meld/Ruleset）、**ユーティリティ層**（ScoreCalculatorインタフェース、牌管理）に分けて実装します。

## API仕様と主なユースケース

* **`GameManager` クラス**

  * メソッド例: `StartGame()`, `EndGame()`, `StartRound()`, `NextTurn()`, `DrawTile()`, `DiscardTile(Tile)`, `ClaimMeld(Player, MeldType)`, `DeclareRiichi()`, `DeclareWin(WinType)` など。内部で状態遷移やルール適用を行います。
  * イベント例: `OnDraw(Player, Tile)`, `OnDiscard(Player, Tile)`, `OnMeldClaimed(Player, Meld)`, `OnRiichiDeclared(Player)`, `OnWin(Player, WinInfo)`, `OnRoundEnd(RoundResult)` などを公開し、UI/AIが購読可能とします。

* **`Player` クラス**

  * プロパティ: `Id`, `Name`, `Hand`, `Score`, `IsDealer`, `InRiichi`, `RemainTilesCount` など。
  * メソッド: `Draw()`（GameManagerから呼出し）、`Discard(Tile)`, `RequestRiichi()`, `CanChi(Tile)`, `CanPon(Tile)`, `CanKan(Tile)`, `DeclareKan(Tile)` など。これらは GameManager 経由で呼ばれ、成功可否や次状態を返します。

* **`Wall` クラス**

  * メソッド: `InitializeTiles()`, `DrawTile()`, `KanDrawTile()`, `RevealDora()`.
  * 属性: 残り枚数、嶺上枚数などを提供。

* **`River` クラス**

  * メソッド: `AddDiscard(Player, Tile)`, `GetDiscards(Player)`.
  * 捨て牌情報の取得・管理を行い、フリテン判定などに利用します。

* **その他**: `Ruleset`（ルール設定）、`Meld`（副露情報）、`Tile`（牌データ）、`IScoreCalculator`（点数計算インターフェース）などを用意します。

### 主なユースケース（処理フロー例）

1. **ゲーム開始**: `GameManager.CreateGame(ruleset)` により新規ゲーム作成。必要なプレイヤーを `AddPlayer(Player)` で登録し、`StartGame()` で東1局スタート。`Wall` を初期化して配牌（各13枚、親は14枚）を各プレイヤーの `Hand` に配る。ドラ表示牌を決定。
2. **ツモ→打牌**: 親から順に、`Player.Draw()` で牌山から引き、`Player.Discard(tile)` で牌を捨てる。この間、`GameManager` は他プレイヤーに対してポン/チー/カン可能か判定し、可否を問う。捨て牌は `River` に追加。
3. **鳴き（チー/ポン/カン）**: プレイヤーが放銃牌を `ClaimMeld(otherPlayer, meldType)` で鳴くと、その牌を自手の副露（`Meld`）に登録し、対応する打牌枚数を捨て牌から手牌に移し替える。ポン・暗槓・加槓・明槓を区別し、暗槓では手牌から3枚、明槓では場から1枚といった処理を行う。複数人のロン（ダブル/トリプルロン）は `DeclareWin` 処理で複数登録可能にします。
4. **リーチ**: プレイヤーが聴牌時に `RequestRiichi()` するとリーチ宣言。1000点を供託に積み（`Player.Score -= 1000`）、以降隠し牌2枚のみ触る以外フリー牌として扱う。`Ruleset` で赤ドラや食い断可否もここで影響します。
5. **和了**: 誰かがロンまたはツモで和了できると (`DeclareWin(winType)` 呼出)、その時点の聴牌形とドラ表示から `IScoreCalculator` を呼んで翻・符を計算し、順位に応じた点数移動を行う。供託・本場点はルールに沿って加減算し、勝者の得点に上乗せします。全局終了条件が満たされたら `RoundEnd()` で結果をまとめ、次局またはゲーム終了に移行。
6. **局進行**: ツモ番が終わる（流局 or 和了）と `GameManager` が連荘判定。**ノーテン親流れ**なら親番交代、**聴牌親連荘**なら親継続、といった天鳳ルール通りに決定します。局風（東/南）や局数を更新し、南入やサドンデス終了条件（30000点到達）をチェックします。
7. **ゲーム終了**: いずれかの終了条件（東南戦規定の最終局経過、誰かの飛び終了、サドンデス）に該当すれば `GameManager.EndGame()` を呼び、最終成績（順位、ウマ適用）を確定します。最終供託は1位のプレイヤーに加算します。

以上のように、開発者は各クラスのメソッドを呼び出すことで対局の流れを制御できます。イベント機構を使えば、UIやAIがこれらの動作に応答でき、結果を反映できます。

## 開発ステップとマイルストーン

1. **要件定義・設計フェーズ**

   * 天鳳ルールの詳細調査（開始点数25000、返し30000点、赤ドラ3枚、連荘規則など）と仕様書作成。
   * クラス図やシーケンス図を描き、責務分担を決定（前項のクラス構成）。
   * API仕様書とユースケースのドキュメント化。

2. **プロトタイプ実装（コア機能）**

   * **牌モデルと牌山**: `Tile`クラス実装、`Wall.Initialize()` と `DrawTile()` の動作確認。
   * **配牌処理**: プレイヤーへの初期配牌（ツモと配牌確認）。
   * **順番処理**: プレイヤー順循環とツモ・打牌の基本ループ実装。ユニットテストで順序や牌山残枚数を検証。

3. **対局ロジック実装**

   * **鳴き処理**: チー・ポン・カンの判定と `ClaimMeld` 実装。
   * **リーチ処理**: 聴牌判定とリーチ宣言、供託点の管理。
   * **和了判定**: `IsWinningHand()` の実装（点数計算モジュール連携のための手形検査まで）。
   * **連荘・飛び**: ノーテン親流れ、聴牌親連荘、飛び判定実装。

4. **API整備とドキュメント**

   * パブリックAPI（各クラスのメソッド・イベント）の最終調整。
   * XMLコメントやドキュメント生成ツールでAPI説明を整備。

5. **点数計算連携**

   * 既存の点数計算モジュール（外部）を組み込み、和了時に呼び出す。モジュールの入出力形式に合わせてデータ変換を行うアダプタ層を実装。
   * 臨界ケース（役満複合、三家和、カンドラ数変化など）のテスト。

6. **テスト・検証**

   * **ユニットテスト**: 各クラス単位（Wall、Hand、Player、GameManager など）のメソッド動作テスト。牌山からのツモ分布、鳴き判定、リーチ時の動作確認など細かく実装。
   * **統合テスト**: 完全な一局・東南戦シミュレーションで仕様通りに進行するか検証。既知の牌譜を再現し、結果が期待通りになるかチェック。
   * 継続的インテグレーション (CI) 環境でビルド・テストが自動実行されるように設定します。

7. **リファクタリング・改善**

   * 初期実装で気づいた設計上の冗長部や性能問題をリファクタリング。コードカバレッジを確認しつつ、可読性・保守性を高めます。
   * 拡張性の向上（新ルール追加時の修正範囲を最小化）を再検討し、`Ruleset`や各判定ロジックを分離。

8. **ドキュメント・サンプル**

   * 使用例やユースケースを示すサンプルコードの作成（例えば「CUIデモ」や「牌譜入力で再生」など）。
   * NuGetパッケージ化、インストール方法や依存関係の説明を含めた開発者向けガイドの作成。

## 参考OSS・ゲームと参考点

* **Tenhou（天鳳）ルール**: 天鳳は25000点持ち、返し30000点、赤ドラ3枚（各色1枚）、ウマ10-20、ノーテン親流れ/聴牌親連荘、サドンデス終了など独自ルールがあります。これらはライブラリの規定値・挙動設定に反映すべき仕様です。
* **Riichi.NET (senritsu)**: C#製ライブラリで、ゲーム状態の完全なモデル化と一般的ルール実装を目指しており、設計の参考になります。特にフェーズ1（ゲーム進行モデル）、フェーズ2（役判定・点数計算連携）に注目して構造を学べます。
* **kobalab/majiang-core（JS）**: 手牌(`Shoupai`)、牌山(`Shan`)、河(`He`)クラスなど、麻雀の基本要素をクラス化して提供しています。局進行用の `Game` クラスやプレイヤー基底クラスもあり、機能分割の参考になります。また、その上位プロジェクト **kobalab/Majiang** はロジック(core)、AI、UI、サーバーなどを分離するモジュール構成となっているため、責務分離の例として有益です。
* **summivox/riichi-core (JS)**: イベントソーシングを採用した日本麻雀エンジンで、クリーンなAPIと拡張可能なルール設計を特徴とします。このような設計思想（可変ルールやログ出力、クライアント－サーバ対応）は、本ライブラリにも応用できます。
* **nkgw-marronnier/Mahjong (JS)**: HTML5+JSの麻雀ゲームで、日本式ルール（立直麻雀）として実装されています。東日本/西日本式赤ドラ設定などのローカルルールオプションも扱っており、赤ドラ導入等の実装例の参考になります。
* **麻雀魂 (MahjongSoul)**: オンライン対戦麻雀ゲーム（閉源）ですが、そのプロトコルや牌譜解析ツールがオープンになっています。たとえば `vg-mjg/majsoul-api` では麻雀魂のWebSocket APIを解析しており、ネットワーク対戦を念頭に置く場合の通信仕様やログ取得の参考になります。
* **その他**: 三麻対応は現状不要ですが、3人打ちでルールが変わる場合（ドラ計算・王牌など）もあるため、将来の拡張を考慮するなら構造設計に柔軟性を残しておきます。

これらのOSSやゲームの設計・実装を参照しつつ、C#でのクラス・構造を明確に定義することで、拡張性と堅牢性を両立したライブラリ設計を目指します。

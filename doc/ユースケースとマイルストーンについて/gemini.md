# **麻雀コアロジックライブラリ：設計及び開発仕様書**

## **I. 序論**

### **目的**

本仕様書は、4人打ち立直麻雀（リーチマージャン）のコアゲームロジックを実装する、再利用可能なC\#ライブラリの要件、アーキテクチャ、API設計、及び開発計画を定義することを目的とします。本ライブラリは天鳳ルールを基準とします。

### **スコープ**

本ライブラリは、ゲーム状態管理（プレイヤー、壁牌、手牌、河、基本点数）、プレイヤーアクション（ツモ、打牌、鳴き、立直、和了宣言）、ルール検証、及びゲームフロー制御（ターン進行、局進行、ゲーム終了）をカプセル化します。

### **スコープ外**

ユーザーインターフェース（UI）、人工知能（AI）、ネットワーク通信、及び複雑な最終的な手計算ロジックは本ライブラリのスコープ外とします。ただし、手計算ロジックに関しては、外部モジュールとの連携点を定義します。

### **対象読者とコンテキスト**

本仕様書は、個人の趣味プロジェクトとして麻雀ゲーム開発を行うC\#開発者を対象としています。堅牢な麻雀ゲームの基盤構築に必要な技術的詳細を提供します。

### **主要設計目標**

モジュール性、再利用性、テスト容易性、明瞭性、天鳳立直麻雀ルールへの準拠を主要な設計目標とします。

## **II. コアドメインモデル**

### **目的**

立直麻雀ゲームの核となるエンティティを表す基本的なC\#クラス及び構造体を定義します。これはライブラリの状態表現の基盤となります。

### **A. Tile（牌）表現**

麻雀牌を表現する基本的なデータ構造です。

* Suit: 牌の種類を示す列挙型（例: Manzu, Pinzu, Souzu, Honor）。  
* Rank: 数牌の場合は1から9の整数、字牌の場合は特定の識別子（例: 東、南、西、北、白、發、中）に対応する値または列挙型。  
* IsRedDora: 赤ドラ牌（通常、五萬、五筒、五索に各1枚）であるかを示すブール値。天鳳ルールにおける赤ドラの存在を正確にモデル化するために不可欠です。  
* Id: 各牌を一意に識別するための識別子（例: 0から135）。同一種類の牌（例: 4枚の「一萬」）を区別する必要がある場合に重要となります。これは特にカンの処理や、詳細なログ記録、リプレイ機能の実装において役立ちます。  
* **設計考察:** Tileは構造体（struct）とクラス（class）のどちらにすべきか。牌が不変の値として扱われる場合、不変性（Immutability）を考慮すると構造体が適している可能性があります。

### **B. Meld（副露/鳴き）表現**

プレイヤーが他のプレイヤーの捨て牌を利用して完成させる面子（メンツ）、または自身のツモで完成させる暗槓（アンカン）を表現します。

* 基底クラス/インターフェース: Meld。  
* 派生クラス: Chi（チー）、Pon（ポン）、Kan（カン）。カンの種類（大明槓、暗槓、加槓）は、それぞれ異なる状態遷移（ドラ表示牌の追加、槍槓の可能性など）を引き起こすため、明確に区別する必要があります。これは、Kanクラスのプロパティ（例: KanType列挙型）または派生クラス（例: OpenKan, ClosedKan, AddedKan）によって表現できます。  
* Tiles: その面子を構成するTileのリスト。  
* SourcePlayerIndex: どのプレイヤーから鳴いたかを示すインデックス（ポン、カン、チーの場合）。どのプレイヤーの捨て牌に対してアクションが行われたかを追跡します。  
* ExposedTile: 他のプレイヤーから鳴いた特定のTile（どの牌を鳴きの対象としたか）。  
* **設計考察:** 天鳳ルール準拠のため、カンの種類を正確にモデル化することが極めて重要です。大明槓（ダイミンカン）、暗槓（アンカン）、加槓（カカン、小明槓とも）は、ゲーム状態（ドラ表示、嶺上開花、槍槓の可能性）に異なる影響を与えるため、データ構造上で区別できる必要があります。

### **C. Hand（手牌）表現**

プレイヤーが保持する手牌の状態を管理します。

* ConcealedTiles: 門前の手牌（Tileのリスト）。常にソートされていると、聴牌（テンパイ）判定や構成分析が効率化されます。  
* OpenMelds: 副露した面子（Meldのリスト）。  
* IsConcealed(): 手牌が門前清（メンゼンチン）状態か（一切鳴いていないか）を判定するメソッド。  
* 牌の追加/削除、面子の形成を行うメソッド。  
* **設計考察:** 手牌の聴牌判定、外部の役判定モジュールへの情報提供、アクションの妥当性検証などを効率的に行うためのデータ構造を検討します。牌のリストに加えて、牌の種類ごとの枚数を持つ頻度マップ（例: Dictionary\<TileBase, int\>）を併用すると、特定の牌の検索や判定が高速化される可能性があります。

### **D. WallManager（壁牌/山）管理**

ゲームで使用される牌山全体を管理します。

* Tiles: 壁牌本体を表すQueue\<Tile\>またはList\<Tile\>。  
* DeadWallTiles: 王牌（ワンパイ）を表すList\<Tile\>。嶺上牌（リンシャンハイ）を含みます。  
* DoraIndicators: ドラ表示牌のTileリスト。  
* UraDoraIndicators: 裏ドラ表示牌のTileリスト。  
* メソッド: ShuffleAndBuild()（牌山の生成とシャッフル）、DrawTile()（牌山からツモる）、DrawReplacementTile()（カンの際の嶺上牌をツモる）、RevealDoraIndicator()（ドラ表示牌をめくる）、GetDoraTiles()（現在のドラ牌リストを取得）、GetUraDoraTiles()（局終了時に裏ドラ牌リストを取得）。  
* **設計考察:** 136枚の牌、14枚の王牌、初期ドラ表示牌、カンによる新ドラ表示牌のめくりなど、立直麻雀特有の牌山構造を正確に処理する必要があります。特にドラと裏ドラの表示牌は明確に区別して管理することが、スコア計算の正確性に直結します。堅牢なシャッフルアルゴリズムの実装も重要です。

### **E. DiscardPile（河）表現**

プレイヤーが捨てた牌の履歴を管理します。

* DiscardedTiles: 捨てられた牌の情報（Discardオブジェクト）のリスト。Discardオブジェクトには、捨てられたTile自体に加え、メタデータ（例: TurnNumber（捨てられた巡目）、WasCalled（鳴かれたか）、IsRiichiDeclaration（立直宣言牌か））が含まれることが考えられます。  
* メソッド: AddDiscard()（捨て牌を追加）、GetLastDiscard()（最後の捨て牌を取得）、WasTileDiscarded(Tile)（指定した牌が過去に捨てられているか確認）。  
* **設計考察:** 捨て牌のメタデータを追跡することは、フリテン（自身の和了牌が自分の捨て牌に含まれている、または同巡内の見逃し）や一発（立直後、1巡以内に和了）といったルールの判定に不可欠です。立直宣言牌を横向きにするなどの表現も、このメタデータで管理できます。

### **F. PlayerState（プレイヤー状態）**

各プレイヤーの局における状態を保持します。

* PlayerID: プレイヤー識別子。  
* SeatWind: 自風（Enum: 東、南、西、北）。  
* Hand: Handオブジェクト。  
* DiscardPile: DiscardPileオブジェクト。  
* Points: 現在の持ち点（整数）。  
* IsRiichi: 立直中かどうかのブール値。  
* RiichiTurn: 立直宣言した巡目（整数）。一発判定に使用します。  
* IsMenzen: 門前状態かどうかのブール値（Handの状態から導出可能）。  
* TemporaryFuriten: 一時的なフリテン状態か（同巡内のロン見逃し）。  
* PermanentFuriten: 永続的なフリテン状態か（和了牌が自身の捨て牌にある、または過去にロンを見逃した）。  
* **設計考察:** このオブジェクトは、局中のプレイヤー固有の情報をすべてカプセル化します。立直状態、宣言巡目、そして特に複雑なフリテン状態（一時的/永続的）の追跡は、コアロジックとしてライブラリ内部で正確に管理する必要があります。これは天鳳ルールで要求される重要な機能です。持ち点の基本的な変動（立直棒供託など）もここで管理されます。

### **G. GameState（ゲーム状態）**

ゲーム全体の現在の状態を保持します。

* Players: PlayerStateのリスト（通常、東家から反時計回りの順序）。  
* Wall: WallManagerオブジェクト。  
* CurrentTurnPlayerIndex: 現在の手番プレイヤーのインデックス。  
* PrevalentWind: 場風（Enum: 東、南）。  
* RoundNumber: 局数（例: 東1局なら1、南4局なら8）。  
* Honba: 本場数（連荘や流局による積み数）。  
* RiichiSticks: 供託された立直棒の数。  
* LastAction: 直前のアクションに関する情報（例: 打牌、カン）。ルール判定（例: 一発）のコンテキストとして必要になる場合があります。  
* **設計考察:** GameStateを大部分不変にするか、不変なスナップショットを提供する設計を検討します。これはデバッグ、将来的なAI開発（状態評価）、あるいはアンドゥ/リプレイ機能の実装を容易にします。また、状態遷移に関する推論を単純化する効果もあります。このオブジェクト、またはその派生データが、外部のスコア計算モジュールに渡される主要な情報源となります。そのため、包括的であることが求められます。

## **III. ユースケース分析**

### **目的**

ライブラリの利用者（ゲームアプリケーション）が行う主要なインタラクション（ユースケース）を列挙し、詳細化します。これにより、ライブラリの機能要件が定義されます。

### **A. ゲームセットアップ**

* **アクション:** 新しいゲームを開始する。  
* **ステップ:**  
  1. MahjongGameインスタンスを生成する。  
  2. プレイヤーの席順と起家（最初の親）を決定し、初期の自風を割り当てる。  
  3. WallManagerを使用して牌山を生成・シャッフルする。  
  4. 各プレイヤーに初期手牌（13枚）を配る (WallManagerから牌を取得し、PlayerState.Handに追加)。  
* **関与オブジェクト:** MahjongGame, WallManager, PlayerState, Hand.

### **B. プレイヤーターンサイクル**

* **アクション:** あるプレイヤーの1ターンを実行する。  
* **ステップ:**  
  1. **ターン開始:** 現在のプレイヤーを特定する (GameState.CurrentTurnPlayerIndex)。  
  2. **牌をツモる:** プレイヤーは牌山から牌を1枚ツモる (WallManager.DrawTile())。この時点で、ツモ和了、暗槓、加槓の宣言が可能かチェックする。  
  3. **プレイヤーの意思決定:** プレイヤーは、打牌、ツモ和了宣言、暗槓宣言、加槓宣言のいずれかを選択する。  
  4. **牌を捨てる:** プレイヤーは手牌から1枚選んで捨てる (PlayerState.Hand.RemoveTile(), PlayerState.DiscardPile.AddDiscard())。立直宣言を伴う場合は、それを示す。  
  5. **捨て牌に対する他プレイヤーのアクション確認:** 他のプレイヤーが、その捨て牌に対してチー、ポン、大明槓、またはロンを宣言できるかチェックする。  
  6. **ターン終了:** 他家からのアクション宣言がなければ、次のプレイヤーに手番を移す。  
* **関与オブジェクト:** MahjongGame, GameState, PlayerState, Hand, WallManager, DiscardPile.

### **C. 鳴き（チー、ポン、カン）の実行**

* **アクション:** プレイヤーが他家の捨て牌に対してチー、ポン、大明槓を宣言する、または自身のターンに暗槓・加槓を宣言する。  
* **ステップ:**  
  1. **妥当性検証:** 宣言の合法性（牌の組み合わせ、チーの順序、ポン/カンの同一性など）を検証する。  
  2. **状態更新:** プレイヤーのHandを更新（牌を手牌からOpenMeldsに移動）。GameStateを更新（必要に応じて手番を変更、カン固有のロジック（嶺上牌のツモ、新ドラ表示）を実行）。チー/ポンの後は打牌が必要。  
  3. **フリテンチェック:** ロンを見逃したことによる一時的フリテンなどをチェック・更新する。  
* **関与オブジェクト:** MahjongGame, PlayerState, Hand, WallManager, Tile, Meld.  
* **設計考察:** 検証ロジックは天鳳ルールに厳密に従う必要があります（例: 食いタンなしルールの適用、正しい牌の組み合わせ、宣言のタイミング）。特にカンの処理は、嶺上牌の補充とドラ表示牌の開示を正確に行う必要があり、複雑な状態管理が伴います。

### **D. 立直（リーチ）の宣言**

* **アクション:** プレイヤーが打牌時に立直を宣言する。  
* **ステップ:**  
  1. **妥当性検証:** 立直の合法性（門前であること、聴牌していること、持ち点が1000点以上あること）を検証する。この聴牌判定はライブラリ内部のコアロジックとして実装される必要があります。  
  2. **状態更新:** PlayerState.Pointsから1000点を供託する。GameState.RiichiSticksを1増やす。PlayerState.IsRiichiフラグとRiichiTurnを設定する。DiscardPileに捨て牌を追加する際、立直宣言牌であることを示す（例: 横向きにする表現のためのメタデータ）。  
* **関与オブジェクト:** MahjongGame, GameState, PlayerState, Hand, DiscardPile.  
* **設計考察:** 立直の前提条件である聴牌判定は、手牌の可能な全ての和了形を探索する必要があり、ライブラリの中でも複雑なロジックの一つです。点数供託といったゲーム進行に関わる状態変更も、コアロジックの責任範囲です。

### **E. 和了（ホーラ）の宣言（ツモ、ロン）**

* **アクション:** プレイヤーが和了を宣言する。  
* **ステップ:**  
  1. **妥当性検証:** 和了の合法性（手牌が和了形を構成していること、役が最低一つ存在すること）を検証する。**注意:** ここでの検証は、和了形が完成しているかの基本的なチェックであり、複雑な役の判定や点数計算そのものは行いません。  
  2. **和了種別の判定:** ツモ和了（自摸）かロン和了（栄和）かを判定する。  
  3. **ゲームフロー停止:** その局のゲーム進行を停止し、結果処理フェーズへ移行する。  
* **関与オブジェクト:** MahjongGame, GameState, PlayerState, Hand, Tile.  
* **設計考察:** このアクションは、外部のスコア計算モジュールとの連携が開始される主要なトリガーポイントです。ライブラリは、和了の基本的な可能性（和了形が完成しているか）を検証しますが、スコアは計算しません。代わりに、スコア計算に必要な全てのコンテキスト情報（ScoringContext）を収集し、外部モジュールに渡す準備をします。

### **F. 流局（リュウキョク）の処理**

* **アクション:** 和了者が出ずに局が終了する。  
* **ステップ:**  
  1. **流局条件の検出:** 流局条件（例: 王牌を除く壁牌が全て無くなる（荒牌平局）、特定の途中流局条件（九種九牌、四風連打、四開槓、三家和））を検出する。  
  2. **聴牌/不聴判定:** 各プレイヤーが聴牌（テンパイ）か不聴（ノーテン）かを判定する。  
  3. **点数授受:** 不聴罰符（ノーテンバップ）の点数移動を行う。  
  4. **状態更新:** 本場カウンター (Honba) を増やす。親が不聴の場合、次の局で親を移動（輪荘）する。  
* **関与オブジェクト:** MahjongGame, GameState, WallManager, PlayerState.  
* **設計考察:** 天鳳で採用されている様々な流局条件（特に途中流局）のチェックを実装する必要があります。不聴罰符の計算のために、各プレイヤーの聴牌状態を正確に判定するロジックも不可欠です。

### **G. 局終了 / ゲーム終了**

* **アクション:** 和了または流局により局を終了する。  
* **ステップ:**  
  1. **スコア計算トリガー:** 外部スコア計算モジュールとの連携を開始する（和了の場合）。  
  2. **点数更新:** スコア計算結果、供託立直棒、本場に基づき、各プレイヤーの持ち点を更新する。  
  3. **ゲーム終了条件確認:** ゲーム終了条件（例: 持ち点がマイナスになる（飛び）、最終局（オーラス）が終了）を確認する。  
  4. **次局準備（ゲーム続行の場合）:** 次の局を開始する（親の移動、本場の処理（親和了なら連荘、それ以外はリセット）、壁牌の再生成・配牌）。  
* **関与オブジェクト:** MahjongGame, GameState, PlayerState.

### **ユースケースサマリー表**

| ユースケース名 | 説明 | 主要アクター | 関与するコアオブジェクト | 主要な事前条件 | コアアクション | 主要な事後条件/状態変化 |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| ゲームセットアップ | 新規ゲームを開始し、最初の局の準備を行う | ライブラリ利用者 | MahjongGame, WallManager, PlayerState, Hand | なし | 牌山生成、配牌 | ゲーム状態初期化、第1局開始準備完了 |
| プレイヤーターンサイクル | プレイヤーが牌をツモり、打牌または他のアクションを行う一連の流れ | プレイヤー | MahjongGame, GameState, PlayerState, Hand, WallManager | 該当プレイヤーのターン | ツモ、打牌（またはカン、ツモ和了） | 手牌更新、河更新、ターンプレイヤー変更（または局終了） |
| 鳴き（チー、ポン、カン） | 他家の捨て牌、または自身のツモ牌で面子を完成させる | プレイヤー | MahjongGame, PlayerState, Hand, WallManager, Meld | 鳴き可能な牌とタイミング | 妥当性検証、手牌更新（副露）、状態更新（ドラ表示、嶺上牌ツモなど） | 手牌が非門前状態へ、面子確定、打牌へ移行（チー・ポン後）またはツモへ（カン後） |
| 立直宣言 | 門前聴牌時に1000点供託して立直を宣言する | プレイヤー | MahjongGame, GameState, PlayerState, Hand, DiscardPile | 門前、聴牌、1000点以上所持 | 妥当性検証、点数供託、状態フラグ設定、宣言牌打牌 | プレイヤー立直状態、供託棒増加、以降ツモ切り強制（和了・カン以外） |
| 和了宣言（ツモ、ロン） | 和了形を完成させ、局の終了を宣言する | プレイヤー | MahjongGame, GameState, PlayerState, Hand, Tile | 和了可能な手牌と牌、役あり | 妥当性検証（基本形）、和了種別判定 | 局終了、スコア計算コンテキスト生成 |
| 流局処理 | 和了者が出ずに局が終了した場合の処理を行う | システム | MahjongGame, GameState, WallManager, PlayerState | 流局条件成立（壁牌切れ、途中流局） | 流局種別判定、聴牌/不聴判定、不聴罰符授受 | 局終了、点数更新（不聴罰符）、本場増加、親流れ判定 |
| 局終了/ゲーム終了 | 局の結果を処理し、ゲームを続行するか終了するかを決定する | システム/ライブラリ利用者 | MahjongGame, GameState, PlayerState | 和了または流局発生 | 点数更新（和了点、罰符）、ゲーム終了条件判定、次局準備（またはゲーム終了） | プレイヤー点数更新、ゲーム状態更新（局、本場、親）、ゲーム終了または次局開始準備完了 |

## **IV. API設計仕様**

### **目的**

ライブラリの公開インターフェース（利用側アプリケーションが使用するクラス、メソッド、プロパティ、イベント）を定義します。明瞭性、使いやすさ、堅牢性を重視します。

### **A. メインゲームコントローラー (MahjongGame クラス)**

ゲーム全体の進行とルール適用を管理する中心的なクラスです。

* **コンストラクタ:** MahjongGame(List\<IPlayerAgent\> playerAgents)  
  * プレイヤーを表すエージェント（人間の入力ハンドラやAIなど）のリストを受け取ります。これにより、ゲームロジックとプレイヤーの意思決定ロジックが分離されます。  
* **プロパティ:** GameState CurrentState { get; }  
  * 現在の（可能であれば不変な）ゲーム状態のスナップショットを取得します。外部はこのプロパティを通じて現在の状況を把握します。  
* **メソッド:**  
  * StartGame(): 最初の局を開始し、ゲームを初期化します。  
  * RequestAction(PlayerAction action): プレイヤーエージェントから提出されたアクション（例: DiscardAction, RiichiAction, PonAction, TsumoAction）を受け付けます。MahjongGameはこのアクションの妥当性を検証し、実行してゲーム状態を更新します。これがゲームを進行させる主要なメカニズムです。  
  * GetValidActions(PlayerID player): 指定されたプレイヤーが現在実行可能な合法的なアクションのリストを取得します。これはUIで選択肢を提示したり、AIが次の手を決定したりするために不可欠です。アクションの可能性を問い合わせる機能（コアロジック）と、実際にアクションを選択・実行する機能を分離することが重要です。  
* **イベント:**  
  * OnGameStart: ゲーム開始時に発生します。  
  * OnRoundStart(GameState initialState): 新しい局が開始されるときに発生し、初期状態を提供します。  
  * OnTurnStart(PlayerID player, GameState state): プレイヤーのターンが開始されるときに発生します。  
  * OnTileDrawn(PlayerID player, Tile tile, GameState state): プレイヤーが牌をツモったときに発生します。  
  * OnTileDiscarded(PlayerID player, Tile tile, bool isRiichiDeclare, GameState state): プレイヤーが牌を捨てたときに発生します。立直宣言牌かどうかの情報も含まれます。  
  * OnCallMade(PlayerID player, Meld meld, GameState state): 鳴き（チー、ポン、カン）が行われたときに発生します。  
  * OnRiichiDeclared(PlayerID player, GameState state): 立直が宣言されたときに発生します。  
  * OnWinDeclared(PlayerID winner, PlayerID? loser, WinType type, ScoringContext context): 和了が宣言されたときに発生します。勝者、放銃者（ロンの場合）、和了タイプ、そしてスコア計算に必要な全ての情報を含むScoringContextを提供します。  
  * OnRoundDraw(DrawType type, Dictionary\<PlayerID, bool\> tenpaiStatus, GameState state): 流局が発生したときに発生します。流局の種類と各プレイヤーの聴牌状態を提供します。  
  * OnRoundEnd(GameState finalState, ScoreChanges scoreChanges): 局が終了し、点数移動が確定したときに発生します。（点数計算を外部で行う場合、ScoreChangesは外部から通知される必要があります）。  
  * OnGameEnd(GameState finalState, FinalScores finalScores): ゲームが終了したときに発生します。最終的な状態とスコアを提供します。  
* **設計考察:** イベントベースのシステムを採用することで、UIやロガーなどの利用側アプリケーションが、MahjongGameの実装に密結合することなく、ゲームのイベントに反応できます。RequestActionパターンは制御フローと検証を一元化します。イベントと共にGameStateのスナップショットを渡すことで、イベント発生時のコンテキストを提供します。

### **B. プレイヤー表現 (IPlayerAgent インターフェース)**

プレイヤーの意思決定を行うコンポーネント（UIハンドラやAI）が実装すべきインターフェースです。

* **メソッド:** PlayerAction GetAction(GameState currentState, List\<PlayerAction\> validActions)  
  * MahjongGameからアクションを要求された際に、利用側アプリケーション（UIハンドラやAI）が実装し、現在のゲーム状態と実行可能なアクションリストに基づいて次のアクションを決定します。  
* **設計考察:** このインターフェースは、コアゲームロジックとプレイヤーの意思決定方法（人間の入力か、AIアルゴリズムか）を明確に分離します。ライブラリは、このインターフェースを通じてのみプレイヤーの意思決定部と対話します。

### **C. コアデータ構造 (セクションIIで定義)**

Tile, Meld, Hand, DiscardPile, PlayerState, GameStateなどのクラスは、必要なプロパティを主にゲッターを通じて公開すべきです。状態の変更は、MahjongGameのメソッドや内部マネージャーを通じてのみ行われるように、可変性（Mutability）を慎重に制御することが望ましいです。

### **D. アクション表現 (PlayerAction 基底クラス)**

プレイヤーの意図を表現するための型安全な方法を提供します。

* **派生クラス:** DiscardAction(Tile tile), ChiAction(Tile tileToCall, Tile tile1, Tile tile2), PonAction(Tile tileToCall), KanAction(KanType type, Tile tile), RiichiAction(Tile discardTile), TsumoAction(), RonAction(), NoAction() (鳴きやロンを見送る場合)。  
* **設計考察:** 具体的なアクションクラスを使用することで、MahjongGame.RequestActionに渡されるプレイヤーの意図が明確になり、型安全性が向上します。

### **API主要メソッド・イベント概要表**

| コンポーネント | メンバー種別 | シグネチャ | 説明 | 利用シナリオ例 |
| :---- | :---- | :---- | :---- | :---- |
| MahjongGame | プロパティ | GameState CurrentState { get; } | 現在のゲーム状態のスナップショットを取得します。 | UIが現在の盤面を表示する、AIが状態を評価する。 |
| MahjongGame | メソッド | StartGame() | ゲームを開始し、最初の局を初期化します。 | 新しい対局を開始するボタンが押されたとき。 |
| MahjongGame | メソッド | RequestAction(PlayerAction action) | プレイヤーからのアクション要求を受け付け、検証・実行し、状態を更新します。 | プレイヤーが打牌ボタンを押した、AIが次の手を決定した。 |
| MahjongGame | メソッド | GetValidActions(PlayerID player) | 指定プレイヤーが現在可能な合法アクションのリストを返します。 | UIで打牌可能な牌や鳴きボタンを有効化する、AIが選択肢を列挙する。 |
| MahjongGame | イベント | OnTurnStart(PlayerID player, GameState state) | プレイヤーのターン開始を通知します。 | UIで現在のプレイヤーをハイライトする、AIに思考を開始させる。 |
| MahjongGame | イベント | OnTileDrawn(PlayerID player, Tile tile, GameState state) | プレイヤーが牌をツモったことを通知します。 | UIでツモ牌を表示する。 |
| MahjongGame | イベント | OnTileDiscarded(PlayerID player, Tile tile, bool isRiichiDeclare, GameState state) | プレイヤーが牌を捨てたことを通知します。 | UIで河に牌を追加する、他プレイヤーの鳴き/ロン判定をトリガーする。 |
| MahjongGame | イベント | OnWinDeclared(PlayerID winner,..., ScoringContext context) | 和了が発生したことを通知し、スコア計算に必要な情報を提供します。 | スコア計算モジュールを呼び出し、結果を表示する。 |
| MahjongGame | イベント | OnRoundDraw(DrawType type, Dictionary\<PlayerID, bool\> tenpaiStatus,...) | 流局が発生したことを通知します。 | 流局結果（不聴罰符など）を表示し、次の局へ進む処理を行う。 |
| IPlayerAgent | メソッド | PlayerAction GetAction(GameState currentState, List\<PlayerAction\> validActions) | ライブラリからアクション選択を要求された際に、プレイヤー（UI/AI）が実装してアクションを返します。 | MahjongGameがGetValidActionsで得た選択肢と共にこのメソッドを呼び出す。 |

## **V. ライブラリ構造 (C\# プロジェクト)**

### **A. 名前空間戦略**

プロジェクト内のコードを論理的に整理し、管理しやすくするための名前空間構成案です。

* Mahjong.Core: ルート名前空間。  
* Mahjong.Core.Model: ドメインモデルクラス（Tile, Meld, Hand, PlayerState, GameStateなど）を配置。  
* Mahjong.Core.Logic: ゲームフロー制御（MahjongGame）、ルール検証ロジック、WallManagerなどを配置。  
* Mahjong.Core.Enums: 共通の列挙型（Suit, Wind, ActionTypeなど）を配置。  
* Mahjong.Core.Events: イベント引数クラスを配置。  
* Mahjong.Core.Actions: プレイヤーアクションクラス（DiscardActionなど）を配置。  
* Mahjong.Core.Interfaces: 公開インターフェース（IPlayerAgent、スコア計算コンテキスト用インターフェースなど）を配置。

### **B. プロジェクト構造**

* 単一のC\#クラスライブラリプロジェクト (Mahjong.Core.csproj) として構成するのがシンプルで管理しやすいでしょう。  
* 極端な疎結合性が求められる場合を除き、インターフェースを別プロジェクト (Mahjong.Core.Abstractions) に分離することは、趣味のプロジェクトとしては過剰かもしれません。

### **C. 依存関係**

* 外部ライブラリへの依存は最小限に抑えることが望ましいです。標準の.NETライブラリのみを使用することを目指します。

### **D. テスト容易性**

* 開発初期段階からテスト容易性を考慮した設計を行います。インターフェース (IPlayerAgent) の使用、依存性注入（DI）（例: 特定のシナリオをテストするためにWallManagerの挙動を差し替える）、ロジックユニットを小さく焦点を絞って実装することなどが有効です。  
* NUnitやxUnitのようなテストフレームワークを使用したユニットテストプロジェクト (Mahjong.Core.Tests) を作成します。  
* **設計考察:** 明確な構造とテスト容易性への配慮は、個人開発の趣味プロジェクトにおいて、開発とメンテナンスを大幅に容易にします。これにより、自信を持ってリファクタリングや機能追加を行えるようになります。

## **VI. 開発計画とマイルストーン**

### **目的**

ライブラリを段階的に開発するためのアプローチを概説します。コア機能の実装を優先し、反復的なテストと改善を可能にします。この計画は、早期に動作する基本部分を構築し、モチベーションを維持しながら進められるように、趣味プロジェクトの性質を考慮しています。

### **フェーズ 1: コアデータ構造と牌山管理 (想定期間: 1～2週間)**

* **タスク:** Tile, Meld 構造体の実装。Hand 表現（初期は門前部分のみ）の実装。WallManager の実装（シャッフル、基本配牌、ドラ表示ロジック）。  
* **目標:** 基本的な構成要素を確立する。牌表現、牌山生成/配牌に関するユニットテストを整備する。

### **フェーズ 2: 基本ゲームフローとターン管理 (想定期間: 2～3週間)**

* **タスク:** GameState, PlayerState（基本バージョン）の実装。MahjongGame の基本構造実装。基本的なターンサイクル（ツモ、必須打牌）の実装。DiscardPile の追跡実装。基本的な局進行（仮の親ローテーション）の実装。  
* **目標:** プレイヤーが牌をツモって捨て、山がなくなるまでゲームが進行する状態を実現する。基本的な状態遷移をテストする。これにより、最も基本的なゲームループが早期に確認できます。

### **フェーズ 3: プレイヤーアクションの実装（鳴き、立直、和了） (想定期間: 3～5週間)**

* **タスク:** チー、ポン、カンのアクションロジックと妥当性検証の実装。Hand 表現を更新し、副露面子を含める。カンの副作用（嶺上牌ツモ、ドラ表示）の実装。立直宣言ロジック（妥当性検証: 点数、門前、聴牌。状態変更: 点数、供託棒、フラグ）の実装。**聴牌判定ロジックの実装が必須**。基本的な和了宣言ロジック（ツモ/ロン検出、基本的な和了形完成チェック \- **役判定はまだ**）の実装。  
* **目標:** プレイヤーが標準的なアクション（鳴き、立直、和了宣言）を実行できるようになる。アクションの妥当性検証と状態更新を徹底的にテストする。聴牌判定はこのフェーズの重要なサブタスクです。

### **フェーズ 4: ルール適用と流局処理 (想定期間: 2～4週間)**

* **タスク:** 詳細なフリテンルール（一時的、永続的）の実装。食いタンなしルールのチェック（適用する場合）。途中流局ルール（九種九牌、四風連打など）の実装。荒牌平局（壁牌切れによる流局）ロジックの実装（聴牌/不聴判定、不聴罰符処理を含む）。本場カウンターロジックの実装。  
* **目標:** 天鳳に基づいたコアなゲームルールが正しく適用されることを保証する。エッジケースや流局条件をテストする。

### **フェーズ 5: API洗練とスコア計算連携 (想定期間: 1～2週間)**

* **タスク:** これまでのフェーズの結果に基づき、公開API（MahjongGame, イベント, アクションクラス）を洗練する。ScoringContext データ構造/インターフェース（セクションVII）を定義・実装する。和了/流局時にScoringContext を収集し、イベントを通じて渡すメカニズムを実装する。公開APIに包括的なXMLドキュメントコメントを追加する。  
* **目標:** ライブラリのインターフェースを最終化し、外部のスコア計算モジュールとのシームレスな連携を保証する。

## **VII. スコア計算モジュールの連携**

### **目的**

コアライブラリと、ユーザーが既に保有するスコア計算モジュールとの間の正確な契約（インターフェース）を定義します。ライブラリはスコア計算自体を行いませんが、計算に必要な全ての情報を過不足なく提供する責任を負います。

### **A. ScoringContext インターフェース/DTO**

このデータ構造は、和了が発生した際、または特定の流局（例: 流し満貫）時に、コアライブラリからスコア計算モジュールへ渡されます。立直麻雀のスコアは非常に多くの要因に依存するため、このコンテキストは包括的である必要があります。

* **必須データ項目:**  
  * WinningPlayer: 和了したプレイヤーのPlayerState（または関連部分のコピー）。持ち点や自風などの情報。  
  * WinningHand: 和了時のHandオブジェクト（門前部分と副露面子の両方）。  
  * WinningTile: 和了を完成させた特定のTile。  
  * WinType: 和了の種類を示すEnum (Tsumo, Ron)。  
  * LoserPlayer: ロン和了の場合、放銃したプレイヤーのPlayerState（またはID）。  
  * GameStateAtWin: 和了時点のGameStateのスナップショット（場風、局数、本場、供託立直棒）。  
  * WallStateAtWin: 和了時点の壁牌の状態（残りの牌数、ドラ表示牌リスト、**裏ドラ表示牌リスト** \- これは極めて重要）。裏ドラの判定には、王牌の中のどの牌が裏ドラ表示牌に対応するかを知っている必要があります。  
  * WinConditionsMet: 和了状況に関するブール値フラグ。例: IsRiichi (立直), IsIppatsu (一発), IsRinshanKaihou (嶺上開花), IsChankan (槍槓), IsHaitei (海底摸月), IsHoutei (河底撈魚), IsDoubleRiichi (ダブル立直), IsTenhou (天和), IsChiihou (地和)。  
* **設計考察:** このリストは、天鳳ルールにおけるスコア計算に影響を与える可能性のある全ての要因を網羅する必要があります。ライブラリは、これらのブール値フラグや状態要素を全て追跡し、提供する責任があります。一つでも情報が欠けると、外部モジュールでのスコア計算が不正確になる可能性があります。

### **B. 連携フロー**

1. MahjongGameが有効な和了宣言（検証済みのTsumoActionまたはRonAction）を検出します。  
2. MahjongGameは、現在のGameStateと関連するPlayerStateから全ての関連データを収集し、ScoringContextオブジェクトを生成します。  
3. MahjongGameはOnWinDeclaredイベントを発生させ、生成したScoringContextをイベント引数として渡します。  
4. ライブラリとスコア計算モジュールをホストしている利用側アプリケーションが、このイベントを捕捉します。  
5. アプリケーションは、受け取ったScoringContextをユーザーのスコア計算モジュールに渡します。  
6. スコア計算モジュールは、受け取った情報に基づいてスコア（符、翻、役リスト、合計点など）を計算し、結果を返します。  
7. アプリケーションはスコア計算結果を受け取り、次の局のためにプレイヤーの持ち点を更新します。この点数更新は、アプリケーションが直接PlayerStateを（安全な方法で）更新するか、あるいはMahjongGameに結果を通知するコールバックメソッド（例: ApplyScoreResult）を呼び出すことで行われます。  
   * **設計決定:** スコア計算結果に基づく点数更新を、MahjongGameへのコールバックで行うか、ホストアプリケーションが完全に外部で処理するかを決定する必要があります。外部で処理する方が、コアライブラリの責務を単純化できます。

## **VIII. 参考資料と更なる考慮事項**

### **A. 参考資料**

* **天鳳ルール:** 天鳳のルールセットに関する信頼できる情報源へのリンク（例: 有志による解説Wiki、ルールページなど）。実装の詳細を確認するための直接的な参照先となります。  
* **立直麻雀Wiki:** 一般的な概念、役の定義、用語集など（例: 日本プロ麻雀連盟ルール、各種オンライン麻雀のルール解説ページ）。  
* **既存ライブラリ（インスピレーションとして）:** mahjong4j (Java) のような既存のライブラリに言及し、アーキテクチャのアイデアを提供することは有益ですが、あくまで独自のC\#実装を作成することを強調します。

### **B. C\# ベストプラクティス**

* **不変性 (Immutability):** 可能な箇所では不変型を使用する（例: Tile、GameStateのスナップショット）。これにより、予測可能性が向上し、スレッドセーフティにも寄与します（ただし、初期スコープではスレッド処理は不要かもしれません）。  
* **非同期処理 (Async/Await):** コアロジック自体には通常不要ですが、後でI/O操作（ログ記録、設定読み込み）を追加する場合や、IPlayerAgent.GetActionがリモートプレイヤーや時間のかかるAIと対話する場合は非同期が役立つ可能性があります。ただし、MahjongGameのメインループは同期的である可能性が高いです。  
* **エラーハンドリング:** 不正な状態や試行された違法なアクションに対して、例外（例: ターン外のアクション試行に対するInvalidOperationException）を適切に使用します。  
* **ロギング:** デバッグやゲームフローの追跡のために、ロギング（例: Microsoft.Extensions.Loggingを使用）のためのフックを追加することを検討します。

### **C. 将来的な拡張の可能性**

* **ルールバリエーション:** MahjongGameをパラメータ化するか、ストラテジーパターンを使用して、異なるルールセット（例: 食いタンあり/なし、異なる開始点数、三人麻雀ルール）に対応できるようにします。  
* **AI連携:** AI自体はスコープ外ですが、IPlayerAgentインターフェースとGameState表現を適切に設計することで、後でAIプレイヤーを追加することが容易になります。  
* **シリアライゼーション:** GameStateのシリアライゼーションを実装し、ゲームの保存/読み込みやリプレイ機能を可能にします。  
* **ネットワーク対戦:** 現在の設計はローカルプレイのロジックに焦点を当てています。ネットワーク対戦に対応するには、状態同期、コマンドパターンなど、現在の基盤の上に大幅な追加が必要になります。

## **IX. 結論**

本仕様書は、天鳳ルールに基づいた4人打ち立直麻雀のコアロジックをカプセル化するC\#ライブラリの設計と開発計画を提示しました。明確に定義されたドメインモデル、詳細なユースケース分析、堅牢なAPI設計、そして段階的な開発計画により、再利用可能でテスト容易性の高いライブラリの構築が可能となります。

特に重要なのは、ライブラリの責務範囲を明確にし、UI、AI、ネットワーク、複雑なスコア計算といった要素を分離することです。スコア計算モジュールとの連携インターフェース(ScoringContext)は、計算に必要な全てのゲーム状態情報を正確に提供するように設計されています。

提案された開発計画は、コアとなるゲームプレイ機能を早期に実現することに重点を置いており、趣味のプロジェクトとしてモチベーションを維持しながら進める上で効果的です。各フェーズでのテストを重視することで、品質の高いライブラリの完成が期待されます。

本仕様書に基づき開発を進めることで、C\#を用いた様々な麻雀アプリケーションの堅牢な基盤となるコアライブラリが実現されるでしょう。